<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="Maxim Sokhatsky"><meta property="og:title" content="The Platform"><meta property="og:image" content="https://voxoz.github.io/platform.rs/index.png"><meta property="og:type" content="website"><meta property="fb:app_id" content="118554188236439"><meta property="og:url" content="https://voxoz.github.io/platform.rs"><meta property="og:description" content="The Platform"><link rel="stylesheet" href="https://voxoz.github.io/platform.rs/main.css?v=2"><title>InterCore</title></head><body><nav class="main-nav"><h1>Stream Processing &amp; Language&nbsp;Platform</h1><ul><li><a href="/">KERNEL</a></li><li><a href="/language">LANGUAGE</a></li><li><a href="/intercore">INTERCORE</a></li><li><a href="/book">BOOK</a></li></ul></nav><header class="header"><div class="header__titles"><h1 class="header__title">InterCore</h1><h4 class="header__subtitle">The System Protocol<br>for Channels and Tasks</h4></div></header><section class="types"><h1 class="types__title" id="taxonomy">API</h1><div class="types__row"><ol class="types__col">                   <li class="types__item"><a href="#Publisher">PUBLISHER</a></li><li class="types__item"><a href="#Subscriber">SUBSCRIBER</a></li><li class="types__item"><a href="#Spawn">SPAWN</a></li><li class="types__item"><a href="#Send">SEND</a></li><li class="types__item"><a href="#Receive">RECEIVE</a></li></ol></div></section><article><h2 id="Abstract">Low Latency Transport</h2><p>The InterCore bus constructed of number of SPMC queues per core. The bus itself
has start topology between cores and MPSC is organized as a computable function
over a set of publisher queues. Each core has exatcly one publisher queue.</p><p>The InterCore protocol handler is called <b>poll_bus</b> and is a member of each <b>Scheduler</b>.
You may think of InterCore as teleport trasnport between processors as <b>poll_bus</b> is being fired
on each yield to scheduler and if any core has any message addressed to you since last yield on your
core, then your core before next task will execute the handler on this message.
</p><h2 id="Publisher">pub [capacity]</h2><p><b>pub</b> creates new publisher CAS cursor for writing. Returns system-wide cursor Id.</p><code>o) p: pub[16]
</code><h2 id="Subscriber">sub [publisher]</h2><p><b>sub</b> created new subscriber CAS cursor based on given writer cursor. Return system-wide cursor Id for reading.</p><code>o) s: sub[p]
</code><h2 id="Spawn">spawn[core;program;cursors]</h2><p><b>spawn</b> created new Task on a given core. The Task could be O program or any LLVM code with compatible FFI.
Also you should specify the ownership list of cursors that are exclusively available to that Task.</p><code>o) spawn[0;"etc/proc0";(0;1)]
</code><h2 id="Send">snd[writer;data]</h2><p><b>snd</b> sends particular data to a given writer cursor. Returns nil if OK.</p><code>o) snd[p;42]
</code><h2 id="Receive">rcv[reader]</h2><p><b>rcv</b> returns data from the given reader cursor. If none then yields to scheduler for another task.</p><code>o) rcv[s]</code></article><footer class="footer"><img class="footer__logo" src="https://voxoz.github.io/platform.rs/stamp.svg?v=2"><span class="footer__copy">2016&mdash;2017 &copy; Tachyonic</span></footer><script src="https://voxoz.github.io/platform.rs/hi.js?v=2"></script></body></html>